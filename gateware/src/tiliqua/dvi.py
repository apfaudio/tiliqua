# Copyright (c) 2024 S. Holzapfel <me@sebholzapfel.com>
#
# SPDX-License-Identifier: CERN-OHL-S-2.0

"""Utilities for generating DVI video timings, also contains a DVI PHY implementation."""

from amaranth import *
from amaranth.lib import wiring
from amaranth.lib.wiring import In, Out

from tiliqua import sim, tmds

class DVITimingGen(wiring.Component):

    """
    State machine to generate pixel position and hsync/vsync/de signals,
    based on a DVI timing modeline that may be changed at runtime.
    """

    class TimingProperties(wiring.Signature):
        """
        Signals used to relay properties of current DVI modeline.
        May be changed at runtime, as long as the DVI cores are in reset.
        """
        def __init__(self, coord_width=12):
            super().__init__({
                "h_active":      Out(coord_width),
                "h_sync_start":  Out(coord_width),
                "h_sync_end":    Out(coord_width),
                "h_total":       Out(coord_width),
                "h_sync_invert": Out(1),
                "v_active":      Out(coord_width),
                "v_sync_start":  Out(coord_width),
                "v_sync_end":    Out(coord_width),
                "v_total":       Out(coord_width),
                "v_sync_invert": Out(1),
                "active_pixels": Out(coord_width*2),
            })

    class ControlSignals(wiring.Signature):
        """
        Outgoing display synchronization signals generated by this core.
        """
        def __init__(self):
            super().__init__({
                "hsync": Out(1),
                "vsync": Out(1),
                "de":    Out(1),
            })

    def __init__(self):
        super().__init__({
            "timings": In(self.TimingProperties()),
            # Control signals without inversion applied.
            # Useful for driving logic external to this core (e.g. do something
            # based on vsync, without having to worry the display might invert it).
            "ctrl": Out(self.ControlSignals()),
            # Control signals with inversion applied.
            "ctrl_phy": Out(self.ControlSignals()),
        })

    def elaborate(self, platform) -> Module:
        m = Module()

        timings = self.timings

        # coordinates at which each frame starts
        self.h_reset = timings.h_active - timings.h_total
        self.v_reset = timings.v_active - timings.v_total

        # coordinates at which sync starts / ends
        self.hs_start = timings.h_sync_start - timings.h_total
        self.vs_start = timings.v_sync_start - timings.v_total
        self.hs_end   = timings.h_sync_end   - timings.h_total
        self.vs_end   = timings.v_sync_end   - timings.v_total

        # current position
        self.x = Signal(signed(12))
        self.y = Signal(signed(12))

        with m.If(ResetSignal("dvi")):
            m.d.dvi += [
                self.x.eq(self.h_reset),
                self.y.eq(self.v_reset),
            ]
        with m.Elif(self.x == (timings.h_active-1)):
            m.d.dvi += self.x.eq(self.h_reset)
            with m.If(self.y == (timings.v_active-1)):
                m.d.dvi += self.y.eq(self.v_reset)
            with m.Else():
                m.d.dvi += self.y.eq(self.y+1)
        with m.Else():
            m.d.dvi += self.x.eq(self.x+1)

        # Generate all control signals based on index.
        # Sync inversion must be handled before the PHY (see below).
        m.d.comb += [
            self.ctrl.hsync.eq((self.x >= self.hs_start) & (self.x < self.hs_end)),
            self.ctrl.vsync.eq((self.y > self.vs_start) &
                               (self.y < self.vs_end) |
                               ((self.y == self.vs_start) & (self.x >= self.hs_start)) |
                               ((self.y == self.vs_end)   & (self.x < self.hs_start))),
            self.ctrl.de.eq((self.x >= 0) & (self.y >= 0)),

        ]

        # Apply inversion where required.
        m.d.comb += [
            self.ctrl_phy.de.eq(self.ctrl.de),
            self.ctrl_phy.hsync.eq(self.ctrl.hsync ^ self.timings.h_sync_invert),
            self.ctrl_phy.vsync.eq(self.ctrl.vsync ^ self.timings.v_sync_invert),
        ]

        return m

class DVIPHY(wiring.Component):

    """
    DVI PHY (serializer), DDR outputs currently ECP5-specific.
    Assumes clock domains 'dvi' (pixel clock) and 'dvi5x' (5x pixel clock).
    """

    # Channel data and control inputs
    de: In(1)           # Data enable (high when drawing)
    data_in_ch0: In(8)  # Channel 0 - data
    data_in_ch1: In(8)  # Channel 1 - data
    data_in_ch2: In(8)  # Channel 2 - data
    ctrl_in_ch0: In(2)  # Channel 0 - control
    ctrl_in_ch1: In(2)  # Channel 1 - control
    ctrl_in_ch2: In(2)  # Channel 2 - control

    def elaborate(self, platform):
        m = Module()

        # TMDS encoders for each channel
        m.submodules.encode_ch0 = encode_ch0 = tmds.TMDSEncoder()
        m.submodules.encode_ch1 = encode_ch1 = tmds.TMDSEncoder()
        m.submodules.encode_ch2 = encode_ch2 = tmds.TMDSEncoder()

        tmds_ch0 = Signal(10)
        tmds_ch1 = Signal(10)
        tmds_ch2 = Signal(10)

        # Connect TMDS encoder inputs
        m.d.dvi += [
            # Channel 0
            encode_ch0.data_in.eq(self.data_in_ch0),
            encode_ch0.ctrl_in.eq(self.ctrl_in_ch0),
            encode_ch0.de.eq(self.de),
            tmds_ch0.eq(encode_ch0.tmds),
            # Channel 1
            encode_ch1.data_in.eq(self.data_in_ch1),
            encode_ch1.ctrl_in.eq(self.ctrl_in_ch1),
            encode_ch1.de.eq(self.de),
            tmds_ch1.eq(encode_ch1.tmds),
            # Channel 2
            encode_ch2.data_in.eq(self.data_in_ch2),
            encode_ch2.ctrl_in.eq(self.ctrl_in_ch2),
            encode_ch2.de.eq(self.de),
            tmds_ch2.eq(encode_ch2.tmds)
        ]

        # Register TMDS signals in the DVI clock domain
        s_tmds_ch0 = Signal(10)
        s_tmds_ch1 = Signal(10)
        s_tmds_ch2 = Signal(10)

        m.d.dvi += [
            s_tmds_ch0.eq(tmds_ch0),
            s_tmds_ch1.eq(tmds_ch1),
            s_tmds_ch2.eq(tmds_ch2)
        ]

        # Serialization logic
        tmds_ch0_shift = Signal(10)
        tmds_ch1_shift = Signal(10)
        tmds_ch2_shift = Signal(10)

        # 5-bit circular shift buffer
        shift5 = Signal(5, reset=1)

        # Serialization in the 5x DVI clock domain
        m.d.dvi5x += [
            shift5.eq(Cat(shift5[4], shift5[0:4]))
        ]

        with m.If(shift5[0]):
            m.d.dvi5x += [
                tmds_ch0_shift.eq(s_tmds_ch0),
                tmds_ch1_shift.eq(s_tmds_ch1),
                tmds_ch2_shift.eq(s_tmds_ch2)
            ]
        with m.Else():
            m.d.dvi5x += [
                tmds_ch0_shift.eq(Cat(tmds_ch0_shift[2:10], Const(0, 2))),
                tmds_ch1_shift.eq(Cat(tmds_ch1_shift[2:10], Const(0, 2))),
                tmds_ch2_shift.eq(Cat(tmds_ch2_shift[2:10], Const(0, 2)))
            ]

        if sim.is_hw(platform):
            dvi_pins = platform.request("dvi")
            m.submodules += [
                Instance("ODDRX1F",
                    i_D0=tmds_ch0_shift[0],
                    i_D1=tmds_ch0_shift[1],
                    i_SCLK=ClockSignal("dvi5x"),
                    i_RST=Const(0, 1),
                    o_Q=dvi_pins.d0.o
                ),
                Instance("ODDRX1F",
                    i_D0=tmds_ch1_shift[0],
                    i_D1=tmds_ch1_shift[1],
                    i_SCLK=ClockSignal("dvi5x"),
                    i_RST=Const(0, 1),
                    o_Q=dvi_pins.d1.o
                ),
                Instance("ODDRX1F",
                    i_D0=tmds_ch2_shift[0],
                    i_D1=tmds_ch2_shift[1],
                    i_SCLK=ClockSignal("dvi5x"),
                    i_RST=Const(0, 1),
                    o_Q=dvi_pins.d2.o
                ),
            ]

        # Clock output
        m.d.comb += dvi_pins.ck.o.eq(ClockSignal("dvi"))

        return m
