# Utilities for synthesizing digital video timings and presenting a framebuffer.
#
# Copyright (c) 2024 Seb Holzapfel <me@sebholzapfel.com>
#
# SPDX-License-Identifier: CERN-OHL-S-2.0

import colorsys
import os

from amaranth              import *
from amaranth.build        import *
from amaranth.lib          import wiring, data, stream
from amaranth.lib.wiring   import In, Out
from amaranth.lib.fifo     import AsyncFIFOBuffered
from amaranth.lib.cdc      import FFSynchronizer
from amaranth.utils        import exact_log2
from amaranth.lib.memory   import Memory

from amaranth_soc          import wishbone

from dataclasses           import dataclass

from tiliqua               import sim, dvi

@dataclass
class DVIPLL:
    clki_div:      int
    clkop_div:     int
    clkop_cphase:  int
    clkos_div:     int
    clkos_cphase:  int
    clkos2_div:    int
    clkos2_cphase: int
    clkos2_cphase: int
    clkfb_div:     int

@dataclass
class DVITimings:
    h_active:      int
    h_sync_start:  int
    h_sync_end:    int
    h_total:       int
    h_sync_invert: bool
    v_active:      int
    v_sync_start:  int
    v_sync_end:    int
    v_total:       int
    v_sync_invert: bool
    pixel_clk_mhz: float
    pll:           DVIPLL

    @property
    def active_pixels(self):
        return self.h_active * self.v_active

    @property
    def refresh_rate(self):
        return (self.pixel_clk_mhz*1e6)/(self.h_total * self.v_total)

DVI_TIMINGS = {
    # CVT 640x480p59.94
    # Every DVI-compatible monitor should support this, according to the standard.
    # These numbers correspond directly to `xrandr --verbose`, if you're reading an EDID.
    "640x480p59.94": DVITimings(
        h_active      = 640,
        h_sync_start  = 656,
        h_sync_end    = 752,
        h_total       = 800,
        h_sync_invert = True,
        v_active      = 480,
        v_sync_start  = 490,
        v_sync_end    = 492,
        v_total       = 525,
        v_sync_invert = True,
        pixel_clk_mhz = 25.175,
        # DVIPLL() instances are generated by looking at the results of incantations like:
        # $ ecppll -i 48 --clkout0 371.25 --highres --reset -f pll60.v
        # where clkout0 is 5x the pixel clock. clkos2_div set by inspection to clkos_div*5.
        pll = DVIPLL(
            clki_div      = 9,
            clkop_div     = 59,
            clkop_cphase  = 9,
            clkos_div     = 5,
            clkos_cphase  = 0,
            clkos2_div    = 25,
            clkos2_cphase = 0,
            clkfb_div     = 2
        )
    ),

    # DMT 800x600p60
    "800x600p60": DVITimings(
        h_active      = 800,
        h_sync_start  = 840,
        h_sync_end    = 968,
        h_total       = 1056,
        h_sync_invert = False,
        v_active      = 600,
        v_sync_start  = 601,
        v_sync_end    = 605,
        v_total       = 628,
        v_sync_invert = False,
        pixel_clk_mhz = 40,
        pll = DVIPLL(
            clki_div      = 2,
            clkop_div     = 25,
            clkop_cphase  = 9,
            clkos_div     = 3,
            clkos_cphase  = 0,
            clkos2_div    = 15,
            clkos2_cphase = 0,
            clkfb_div     = 1
        )
    ),

    # DMT 1280x720p60
    "1280x720p60": DVITimings(
        h_active      = 1280,
        h_sync_start  = 1390,
        h_sync_end    = 1430,
        h_total       = 1650,
        h_sync_invert = False,
        v_active      = 720,
        v_sync_start  = 725,
        v_sync_end    = 730,
        v_total       = 750,
        v_sync_invert = False,
        pixel_clk_mhz = 74.25,
        pll = DVIPLL(
            clki_div      = 15,
            clkop_div     = 58,
            clkop_cphase  = 9,
            clkos_div     = 2,
            clkos_cphase  = 0,
            clkos2_div    = 10,
            clkos2_cphase = 0,
            clkfb_div     = 4
        )
    ),

    "1920x1080p30": DVITimings(
        h_active      = 1920,
        h_sync_start  = 2008,
        h_sync_end    = 2052,
        h_total       = 2200,
        h_sync_invert = False,
        v_active      = 1080,
        v_sync_start  = 1084,
        v_sync_end    = 1089,
        v_total       = 1125,
        v_sync_invert = False,
        pixel_clk_mhz = 74.25,
        pll = DVIPLL(
            clki_div      = 15,
            clkop_div     = 58,
            clkop_cphase  = 9,
            clkos_div     = 2,
            clkos_cphase  = 0,
            clkos2_div    = 10,
            clkos2_cphase = 0,
            clkfb_div     = 4
        )
    ),

    # BEGIN ODDBALL TIMINGS

    # A round AliExpress display
    "720x720p60": DVITimings(
        h_active      = 720,
        h_sync_start  = 760,
        h_sync_end    = 780,
        h_total       = 820,
        h_sync_invert = False,
        v_active      = 720,
        v_sync_start  = 744,
        v_sync_end    = 748,
        v_total       = 760,
        v_sync_invert = False,
        pixel_clk_mhz = 37.40,
        pll = DVIPLL(
            clki_div      = 12,
            clkop_div     = 17,
            clkop_cphase  = 9,
            clkos_div     = 4,
            clkos_cphase  = 0,
            clkos2_div    = 20,
            clkos2_cphase = 0,
            clkfb_div     = 11
        )
    ),
}

COORD_WIDTH = 12

class FramebufferSimulationInterface(wiring.Signature):
    def __init__(self, coord_width=COORD_WIDTH):
        super().__init__({
            "de": Out(1),
            "vsync": Out(1),
            "hsync": Out(1),
            "r": Out(8),
            "g": Out(8),
            "b": Out(8),
        })

class DVITimingInterface(wiring.Signature):
    def __init__(self, coord_width=COORD_WIDTH):
        super().__init__({
            "h_active":      Out(coord_width),
            "h_sync_start":  Out(coord_width),
            "h_sync_end":    Out(coord_width),
            "h_total":       Out(coord_width),
            "h_sync_invert": Out(1),
            "v_active":      Out(coord_width),
            "v_sync_start":  Out(coord_width),
            "v_sync_end":    Out(coord_width),
            "v_total":       Out(coord_width),
            "v_sync_invert": Out(1),
            "active_pixels": Out(coord_width*2),
        })

class DVIControlSignals(wiring.Signature):
    def __init__(self):
        super().__init__({
            "hsync": Out(1),
            "vsync": Out(1),
            "de":    Out(1),
        })

class DVITimingGenerator(wiring.Component):

    """
    State machine to generate pixel position and hsync/vsync/de signals.
    Designed to run in the DVI pixel clock domain.

    Warn: Sync inversion is NOT handled here in case the logic of this block drives
    other signals (e.g. framebuffer vsync). Inversion is handled just before the PHY.
    """

    def __init__(self):
        super().__init__({
            "timings": In(DVITimingInterface()),
            # Control signals without inversion applied.
            # Useful for driving logic external to this core (e.g. do something
            # based on vsync, without having to worry the display might invert it).
            "ctrl": Out(DVIControlSignals()),
            # Control signals with inversion applied.
            "ctrl_phy": Out(DVIControlSignals()),
        })

    def elaborate(self, platform) -> Module:
        m = Module()

        timings = self.timings

        # coordinates at which each frame starts
        self.h_reset = timings.h_active - timings.h_total
        self.v_reset = timings.v_active - timings.v_total

        # coordinates at which sync starts / ends
        self.hs_start = timings.h_sync_start - timings.h_total
        self.vs_start = timings.v_sync_start - timings.v_total
        self.hs_end   = timings.h_sync_end   - timings.h_total
        self.vs_end   = timings.v_sync_end   - timings.v_total

        # current position
        self.x = Signal(signed(COORD_WIDTH))
        self.y = Signal(signed(COORD_WIDTH))

        with m.If(ResetSignal("sync")):
            m.d.dvi += [
                self.x.eq(self.h_reset),
                self.y.eq(self.v_reset),
            ]
        with m.Elif(self.x == (timings.h_active-1)):
            m.d.dvi += self.x.eq(self.h_reset)
            with m.If(self.y == (timings.v_active-1)):
                m.d.dvi += self.y.eq(self.v_reset)
            with m.Else():
                m.d.dvi += self.y.eq(self.y+1)
        with m.Else():
            m.d.dvi += self.x.eq(self.x+1)

        # Generate all control signals based on index.
        # Sync inversion must be handled before the PHY (see below).
        m.d.comb += [
            self.ctrl.hsync.eq((self.x >= self.hs_start) & (self.x < self.hs_end)),
            self.ctrl.vsync.eq((self.y > self.vs_start) &
                               (self.y < self.vs_end) |
                               ((self.y == self.vs_start) & (self.x >= self.hs_start)) |
                               ((self.y == self.vs_end)   & (self.x < self.hs_start))),
            self.ctrl.de.eq((self.x >= 0) & (self.y >= 0)),

        ]

        # Apply inversion where required.
        m.d.comb += [
            self.ctrl_phy.de.eq(self.ctrl.de),
            self.ctrl_phy.hsync.eq(self.ctrl.hsync ^ self.timings.h_sync_invert),
            self.ctrl_phy.vsync.eq(self.ctrl.vsync ^ self.timings.h_sync_invert),
        ]

        return m


class FramebufferPHY(wiring.Component):

    """
    Read pixels from a framebuffer in PSRAM and send them to the display.
    Pixels are DMA'd from PSRAM as a wishbone master in bursts of 'fifo_depth // 2' in the 'sync' clock domain.
    They are then piped with DVI timings to the display in the 'dvi' clock domain.

    Pixel storage itself is 8-bits: 4-bit intensity, 4-bit color.
    """

    def __init__(self, *, fb_base, bus_master,
                 fifo_depth=2048, fb_bytes_per_pixel=1, fixed_dvi_timings: DVITimings = None):

        self.fixed_dvi_timings = fixed_dvi_timings
        self.fifo_depth = fifo_depth
        self.fb_base = fb_base
        self.fb_bytes_per_pixel = fb_bytes_per_pixel

        # Color palette tweaking interface
        super().__init__({
            # We are a DMA master
            "bus":  Out(wishbone.Signature(addr_width=bus_master.addr_width, data_width=32, granularity=8,
                                           features={"cti", "bte"})),
            # Kick this to start the core
            "enable": In(1),
            # Must be updated on timing changes
            "timings": In(DVITimingInterface()),
            # Palette updates
            "palette_rgb": In(stream.Signature(data.StructLayout({
                "position": unsigned(8),
                "red":      unsigned(8),
                "green":    unsigned(8),
                "blue":     unsigned(8),
                }))),
            # Enough information to plot the output of this core to images
            "simif": Out(FramebufferSimulationInterface())
        })

    @staticmethod
    def compute_color_palette():

        # Calculate 16*16 (256) color palette to map each 8-bit pixel storage
        # into R8/G8/B8 pixel value for sending to the DVI PHY. Each pixel
        # is stored as a 4-bit intensity and 4-bit color.
        #
        # TODO: make this runtime customizable?

        n_i = 16
        n_c = 16
        rs, gs, bs = [], [], []
        for i in range(n_i):
            for c in range(n_c):
                r, g, b = colorsys.hls_to_rgb(
                        float(c)/n_c, float(1.35**(i+1))/(1.35**n_i), 0.75)
                rs.append(int(r*255))
                gs.append(int(g*255))
                bs.append(int(b*255))

        return rs, gs, bs

    def elaborate(self, platform) -> Module:
        m = Module()

        if self.fixed_dvi_timings is not None:
            for member in self.timings.signature.members:
                m.d.comb += getattr(self.timings, member).eq(getattr(self.fixed_dvi_timings, member))

        m.submodules.fifo = fifo = AsyncFIFOBuffered(
                width=32, depth=self.fifo_depth, r_domain='dvi', w_domain='sync')
        m.submodules.dvi_tgen = dvi_tgen = DVITimingGenerator()
        # TODO: FFSync needed? (sync -> dvi crossing, but should always be in reset when changed).
        wiring.connect(m, wiring.flipped(self.timings), dvi_tgen.timings)

        # Create a VSync signal in the 'sync' domain.
        # NOTE: this is the same regardless of sync inversion.
        phy_vsync_sync = Signal()
        m.submodules.vsync_ff = FFSynchronizer(
                i=dvi_tgen.ctrl.vsync, o=phy_vsync_sync, o_domain="sync")

        # DMA master bus
        bus = self.bus

        # Current offset into the framebuffer
        dma_addr = Signal(32)

        # DMA bus master -> FIFO state machine
        # Burst until FIFO is full, then wait until half empty.

        # Signal from 'dvi' to 'sync' domain to drain FIFO if we are in vsync.
        drain_fifo = Signal(1, reset=0)
        drain_fifo_dvi = Signal(1, reset=0)
        m.submodules.drain_fifo_ff = FFSynchronizer(
                i=drain_fifo, o=drain_fifo_dvi, o_domain="dvi")
        drained = Signal()

        fb_size_words = (self.timings.active_pixels * self.fb_bytes_per_pixel) // 4

        # Read to FIFO in sync domain
        with m.FSM() as fsm:
            with m.State('OFF'):
                with m.If(self.enable):
                    m.next = 'BURST'
            with m.State('BURST'):
                m.d.comb += [
                    bus.stb.eq(1),
                    bus.cyc.eq(1),
                    bus.we.eq(0),
                    bus.sel.eq(2**(bus.data_width//8)-1),
                    bus.adr.eq(self.fb_base + dma_addr),
                    fifo.w_en.eq(bus.ack),
                    fifo.w_data.eq(bus.dat_r),
                    bus.cti.eq(
                        wishbone.CycleType.INCR_BURST),
                ]
                with m.If(fifo.w_level >= (self.fifo_depth-1)):
                    m.d.comb += bus.cti.eq(
                            wishbone.CycleType.END_OF_BURST)
                with m.If(bus.stb & bus.ack & fifo.w_rdy):
                    with m.If(dma_addr < (fb_size_words-1)):
                        m.d.sync += dma_addr.eq(dma_addr + 1)
                    with m.Else():
                        m.d.sync += dma_addr.eq(0)
                with m.Elif(~fifo.w_rdy):
                    m.next = 'WAIT'
            with m.State('WAIT'):
                with m.If(~phy_vsync_sync):
                    m.d.sync += drained.eq(0)
                with m.If(phy_vsync_sync & ~drained):
                    m.next = 'VSYNC'
                with m.Elif(fifo.w_level < self.fifo_depth//2):
                    m.next = 'BURST'
            with m.State('VSYNC'):
                # drain DVI side. We only want to drain once.
                m.d.comb += drain_fifo.eq(1)
                with m.If(fifo.w_level == 0):
                    m.d.sync += dma_addr.eq(0)
                    m.d.sync += drained.eq(1)
                    m.next = 'BURST'

        # Tracking in DVI domain

        # 'dvi' domain: read FIFO -> DVI PHY (1 fifo word is N pixels)
        bytecounter = Signal(exact_log2(4//self.fb_bytes_per_pixel))
        last_word   = Signal(32)
        with m.If(drain_fifo_dvi):
            m.d.dvi += bytecounter.eq(0)
            m.d.comb += fifo.r_en.eq(1),
        with m.Elif(dvi_tgen.ctrl.de & fifo.r_rdy):
            m.d.comb += fifo.r_en.eq(bytecounter == 0),
            m.d.dvi += bytecounter.eq(bytecounter+1)
            with m.If(bytecounter == 0):
                m.d.dvi += last_word.eq(fifo.r_data)
            with m.Else():
                m.d.dvi += last_word.eq(last_word >> 8)

        rs, gs, bs = self.compute_color_palette()
        m.submodules.palette_r = palette_r = Memory(shape=unsigned(8), depth=256, init=rs)
        m.submodules.palette_g = palette_g = Memory(shape=unsigned(8), depth=256, init=gs)
        m.submodules.palette_b = palette_b = Memory(shape=unsigned(8), depth=256, init=bs)

        rd_port_r = palette_r.read_port(domain="comb")
        rd_port_g = palette_g.read_port(domain="comb")
        rd_port_b = palette_b.read_port(domain="comb")

        # Index by intensity (4-bit) and color (4-bit)
        m.d.comb += rd_port_r.addr.eq(Cat(last_word[0:4], last_word[4:8]))
        m.d.comb += rd_port_g.addr.eq(Cat(last_word[0:4], last_word[4:8]))
        m.d.comb += rd_port_b.addr.eq(Cat(last_word[0:4], last_word[4:8]))

        if sim.is_hw(platform):
            # Instantiate the DVI PHY itself
            m.submodules.dvi_gen = dvi_gen = dvi.DVIPHY()
            m.d.sync += [
                dvi_gen.de.eq(dvi_tgen.ctrl_phy.de),
                # RGB -> TMDS
                dvi_gen.data_in_ch0.eq(rd_port_r.data),
                dvi_gen.data_in_ch1.eq(rd_port_g.data),
                dvi_gen.data_in_ch2.eq(rd_port_b.data),
                # VSYNC/HSYNC -> TMDS
                dvi_gen.ctrl_in_ch0.eq(Cat(dvi_tgen.ctrl_phy.hsync, dvi_tgen.ctrl_phy.vsync)),
                dvi_gen.ctrl_in_ch1.eq(0),
                dvi_gen.ctrl_in_ch2.eq(0),
            ]
        else:
            # hook up simif
            m.d.comb += [
                self.simif.de.eq(dvi_tgen.ctrl_phy.de),
                self.simif.vsync.eq(dvi_tgen.ctrl_phy.vsync),
                self.simif.hsync.eq(dvi_tgen.ctrl_phy.hsync),
                self.simif.r.eq(rd_port_r.data),
                self.simif.g.eq(rd_port_g.data),
                self.simif.b.eq(rd_port_b.data),
            ]

        # palette write interface (p=position, rgb=value)
        wports = [palette_r.write_port(),
                  palette_g.write_port(),
                  palette_b.write_port()]
        # split rgb payload into one write for each rgb memory
        m.d.comb += [
            wports[0].data.eq(self.palette_rgb.payload.red),
            wports[1].data.eq(self.palette_rgb.payload.green),
            wports[2].data.eq(self.palette_rgb.payload.blue),
        ]
        m.d.comb += self.palette_rgb.ready.eq(1)
        # hook up position and stream valid -> write enable.
        for wport in wports:
            with m.If(self.palette_rgb.ready):
                m.d.comb += [
                    wport.addr.eq(self.palette_rgb.payload.position),
                    wport.en.eq(self.palette_rgb.valid),
                ]

        return m
